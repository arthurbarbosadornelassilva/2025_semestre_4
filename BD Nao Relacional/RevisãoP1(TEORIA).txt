BANCO DE DADOS NoSQL - REVIS√ÉO PARA P1 (TEORIA):
-------------------------------------------------------------------------

1 - REVIS√ÉO DO MODELO RELACIONAL (caracter√≠sticas e conceitos gerais):

- Conceitos simples (rela√ß√µes, atributos, tuplas, com√≠nios, etc);
- N√£o considera aspectos f√≠sicos de armazenamento, acesso e desempenho;
- Base para a maioria dos SGBDs que dominam o mercado

Caracter√≠sticas do Modelo Relacional:
	- Estrutura dos dados
		 Conceito do modelo: dom√≠nio, atributo, rela√ß√£o, chave, tupla, inst√¢ncia
    
	- Integridade: Restri√ß√µes b√°sicas para dados e relacionamentos 
		- √â uma regra que deve ser obedecida em todos os estados v√°lidos da base de dados;
		- Garantem que os dados refletem corretamente a realidade modelada;
		- Sem√¢ntica ou dom√≠nio: conjunto de valores que um atributo pode assumir;

		- Integridade de Entidade
   			- Garantia de acesso a todos os dados sem ambiguidade;
    			- Atributos pertencentes a chave-prim√°ria de uma rela√ß√£o n√£o podem ter valor nulo;
    			- A chave prim√°ria representa uma inst√¢ncia de entidade na base de dados;
		- Integridade de Chave
    			- Os valores de uma chave prim√°ria s√£o √∫nicos, n√£o se repetem;
    			- De outra forma: n√£o podem existir duas ou mais linhas com o mesmo valor de chave prim√°ria em uma tabela;
		- Sem√¢ntica (Integridade de Dom√≠nio)
    			- S√£o regras de neg√≥cio implementadas sobre o esquema do banco de dados;
		- Integridade Referencial
    			- Chave estrangeira (FK);
    			- Garantia de relacionamentos v√°lidos;
    			- Os valores que aparecem na FK devem aparecer na PK da rela√ß√£o referenciada, OU ter o valor NULO;
		- Restri√ß√µes de atualiza√ß√£o
    			- Inser√ß√£o: insere tuplas em uma rela√ß√£o
    			- Pode violar 4 restri√ß√µes de integridade: integridade de dom√≠nio, integridade de chave, integridade de entidade e integridade referencial;
    			- Exclus√£o: exclui tuplas de uma rela√ß√£o;
   			 - Atualiza√ß√£o: altera os valores de atributos nas tuplas existentes;
		- A√ß√µes para evitar uma opera√ß√£o que viole as restri√ß√µes de integridade referencial
    			- RESTRICT
			- CASCADE
			- SET NULL
			- SET DEFAULT

	- Manipula√ß√£o: linguagens formais (√°lgebra relacional) & linguagem SQL

Propriedades das rela√ß√µes:
    	1. N√£o existem tuplas em duplicata, as tuplas s√£o √∫nicas;
    	2. Tuplas n√£o s√£o ordenadas de cima para baixo;
    	3. Atributos n√£o s√£o ordenados da esquerda para a direita;
    	4. Cada tupla cont√©m exatamente um valor para cada atributo;

Classes de Comandos SQL
    - DDL
        - Linguagem de Defini√ß√£o de Dados;
        - Usada para defini√ß√£o dos esquemas (CREATE, ALTER, DROP);
    - DML
        - Linguagem de Manipula√ß√£o de Dados;
        - Utilizada pelos usu√°rios para manipula√ß√£o dos dados (inclus√£o, altera√ß√£o e exclus√£o);
    - DCL
        - Linguagem de Controle de Dados;
        - Utilizada para conceder e retirar privil√©gios de usu√°rios de BD em objetos de BD (GRANT e REVOKE);
    - DQL
        - Linguagem de Consulta de Dados;
        - Usada para recupera√ß√£o de dados (SELECT);
    - TCL
        - Linguagem de Controle de Transa√ß√£o;
        - Utilizada para lidar com transa√ß√µes no banco de dados (COMMIT e ROLLBACK);

-----------------------------------//--------------------------------------//-------------------------------------------------//-----------------------------------------------//


2 - BANCO DE DADOS NoSQL & BIG DATA:


## Big Data

O qu√™ significa:
	 Big Data:
   	 - Big Data s√£o dados com maior variedade (diferentes formatos) que chegam em volumes crescentes (tamanho) e com velocidade cada vez maior (gerados em tempo real);
   	 - De forma simplificada, Big Data √© um conjunto de dados maior e mais complexo, especialmente de novas fontes de dados;
   	 - Esses conjuntos de dados s√£o t√£o volumosos que o software tradicional de processamento de dados simplesmente n√£o consegue gerenci√°-los;
	 - No entanto, esses grandes volumes de dados podem ser usados para resolver problemas de neg√≥cios que voc√™ n√£o conseguiria resolver antes;
	 - Big Data designa dados e processos cuja escala, distribui√ß√£o, diversidade e velocidade de cria√ß√£o requer o uso de novas tecnologias de armazenamento, processamento e an√°lise dos dados, isto envolve compet√™ncias em computa√ß√£o, matem√°tica e neg√≥cios;
	Ci√™ncia de Dados x Big Data:
    	- Ci√™ncia de dados
        		- Combina estat√≠stica, matem√°tica, programa√ß√£o, intelig√™ncia artificial e resolu√ß√£o de problemas para capturar dados de maneiras engenhosas, com uma vis√£o diferente para encontrar padr√µes e realizar an√°lises, juntamente com as atividades de limpeza, prepara√ß√£o e organiza√ß√£o dos dados;
		- Em resumo, m√©todos cient√≠ficos para transformar, extrair e analisar informa√ß√µes do grande volume de dados;
	- Big data
   		 - Conjunto de t√©cnicas e ferramentas capazes de armazenar, extrair, organizar e transformar grandes volumes de dados, gerados em diferentes formatos e grande velocidade em informa√ß√µes que possibilitam uma an√°lise ampla e em tempo h√°bil;
   		 - Em resumo, infra-estrutura de Tecnologia (ferramentas para armazenamento, processamento, an√°lise e visualiza√ß√£o);


##Banco de Dados NO-SQL

O que significa:
    - √â uma denomina√ß√£o para bancos de dados n√£o-relacionais, isso n√£o quer dizer que seus modelos n√£o possuem relacionamentos e sim que n√£o s√£o orientados a tabelas;
    - Not Only SQL (N√£o apenas SQL)
    - A tecnologia NoSQL foi iniciada por companhias l√≠deres da Internet;

Caracter√≠sticas Principais:
	- Escalabilidade horizontal
   		 - A escalabilidade horizontal consiste em aumentar o n√∫mero de m√°quinas dispon√≠veis;
   		 - A escalabilidade horizontal em modelos relacionais seria invi√°vel devido a concorr√™ncia;
   		 - Como nos modelos NoSQL n√£o existe bloqueios, esse tipo de escalabilidade √© a mais vi√°vel;
	- Aus√™ncia de esquema ou esquema flex√≠vel
  		  - Apresentam aus√™ncia de esquema ou esquema flex√≠vel, isso permite uma f√°cil aplica√ß√£o da escalabilidade e tamb√©m um aumento na disponilibilidade dos dados;
  		  - Mas tamb√©m devido a essa aus√™ncia, n√£o h√° garantia da integridade dos dados;
	- Suporte a repliaca√ß√£o
   	 	- Permitem a replica√ß√£o de uma forma nativa o que prov√©m uma escalabilidade maior e tamb√©m uma diminui√ß√£o do tempo gasto para a recupera√ß√£o de informa√ß√µes;
	- API Simples
 		   - Para que o acesso √†s informa√ß√µes seja feito da forma mais r√°pida poss√≠vel APIs s√£o desenvolvidas para que qualquer aplica√ß√£o possa ter acesso aos dados do SGBD;
	- Nem sempre √© consistente
 		   - Os bancos de dados NoSQL nem sempre conseguem se manter consistentes, ou seja, o valor do dado lido nem sempre √© o mais atual;
	- Alta disponibilidade
  		  - Confiabilidade, recuperabilidade, detec√ß√£o r√°pida de erros e opera√ß√µes cont√≠nuas;
	- Modos de armazenamento
   		 - Temos os sistemas que: mant√™m suas informa√ß√µes em mem√≥ria realizando persist√™ncias ocasionais, mant√™m suas informa√ß√µes em disco e s√£o configur√°veis;

 Existem 4 categorias de SGBDs NoSQL:
	- Sistemas baseados em armazenamento chave-valor
    		- Cole√ß√£o de chaves √∫nicas associada a um valor, que pode ser qualquer tipo (bin√°rio, string);
	- Sistemas orientados √† coluna
		    - Fam√≠lias de colunas (um reposit√≥rio para colunas, an√°logo a uma tabela do Modelo Relacional) e supercolunas (compostas por arrays de colunas);  
	- Sistemas baseados em grafos
		    - Banco de dados baseado em grafos, nele temos as entidades chamadas de v√©rtices (ou node) que s√£o ligadas entre elas pelas arestas (ou relationships) cada um podendo guardar dados entre os relacionamentos e cada relacionamento pode ter uma dire√ß√£o;
	- Sistemas orientados a documentos
		    - Os documentos s√£o as unidades b√°sicas de armazenamento e estes n√£o utilizam qualquer tipo de estrutura√ß√£o pr√©-definida;
		    - S√£o baseados em JSON (JavaScript Object Notation);

-----------------------------//--------------------------------------//----------------------------------------//---------------------------------------//----------------------------------------//


3 - CONTROLE DE CONCORR√äNCIA & TRANSA√á√ïES EM BANCOS DE DADOS (ABORDANDO CONCEITOS DE ACID, BASE & CAP):

## Controle de Concorr√™ncia

Problema:
    - Escalas n√£o serializ√°veis podem violar a consist√™ncia do BD (Uma escala serializ√°vel em banco de dados (BD) √© um agendamento de execu√ß√£o de transa√ß√µes simult√¢neas que produz um resultado consistente, como se as 	transa√ß√µes tivessem sido executadas uma a uma (em s√©rie), mantendo a integridade do banco de dados)
    - For√ßar um comportamento sequencial fazendo uma transa√ß√£o esperar que a outra execute determinadas opera√ß√µes;
    - DeadLock (impasse): uma transa√ß√£o ter√° que ser deseita para que outra seja realizada (rollback);

    - Protocolos com base em bloqueios (lock)
        - Conjunto de regras que determina quando uma transa√ß√£o pode ou n√£o bloquear ou desbloquear um item de dados;
        - Restringe o n√∫mero de escalas poss√≠veis (serializadas);
        - Pode obrigar que o acesso a dados seja feito de maneira mutuamente exclusiva preservando o isolamento;
        - Enquanto uma transa√ß√£o acessa um item de dados, nenhuma outra pode modific√°-lo;
        - As transa√ß√µes devem solicitar o bloqueio de modo apropriado, dependendo do tipo de opera√ß√£o realizada;
        - O gerenciador de controle de concorr√™ncia concede (grants) o bloqueio para a transa√ß√£o (ela pode ter que esperar);

   - Tipos de bloqueios
        - Compartilhado: Se uma transa√ß√£o Ti obteve um bloqueio compartilhado (denotado por S de share) sobre o item Q, ent√£o Ti pode ler, mas n√£o escrever Q;
        - Exclusivo: Se uma transa√ß√£o Ti obteve um bloqueio exclusivo (denotado por X de eXclusive) sobre o item Q, ent√£o Ti pode tanto ler como escrever Q;
	
	EXEMPLOS:
	- Instru√ß√µes
    		- lock-S(Q): bloqueio no modo compartilhado;
    		- lock-X(Q): bloqueio no modo exclusivo;
    		- unlock(Q): remove todos os bloqueios;
	- Para manter o acesso a um item de dado, a transa√ß√£o precisa primeiro bloque√°-lo. Se j√° estiver incompativelmente bloqueado, o gerenciador n√£o conceder√° o bloqueio at√© que todos os bloqueios incompat√≠veis sejam desfeitos;

   - Tipos de protocolo de bloqueio:
        - Protocolo de bloquieo em duas fases (Two-Phase Locking ou 2PL)
    	- Garante a serializa√ß√£o;
	- Exige que cada transa√ß√£o emita suas solicita√ß√µes de bloqueio e desbloqueio em duas fases: fase de expans√£o e fase de encolhimento;
	
	* FASES DO 2PL:
		- Fase de expans√£o ou crescimento: uma transa√ß√£o pode obter bloqueios, mas n√£o pode liberar nenhum;
		- Fase de encolhimento ou retrocesso: uma transa√ß√£o pode liberar bloqueios, mas n√£o consegue obter nenhum bloqueio novo;
		- N√£o garante a aus√™ncia de deadlock;
		- Pode ocorrer o rollback em cascata;
		
        - Protocolo de commit em duas fases Distribu√≠do
    	- Two-phase commit protocol: 2PC;
    	- A a√ß√£o de commit deve ser ‚Äúinstant√¢nea‚Äù e indivis√≠vel;
    	- Pode ser necess√°ria a coopera√ß√£o de muitos processos, em m√°quinas distintas, cada qual com um conjunto de objetos envolvidos na transa√ß√£o;
    	- Um dos processos √© designado como coordenador (normalmente o pr√≥prio cliente que inicia a transa√ß√£o);
    	- Os demais processos s√£o designados como participantes;
    	- Toda a√ß√£o √© registrada em log, armazenado em mem√≥ria est√°vel, para o caso de falha durante o protocolo;

	* FASES DO 2PC:
		- Fase 1: Vota√ß√£o
    		- O coordenador envia mensagem VOTE_REQUEST para todos os participantes e aguarda as respostas;
    		- Cada participante responde VOTE_COMMIT ou VOTE_ABORT para o coordenador;
		- Fase 2: Decis√£o
    		- Se todos os participarem tiverem respondido VOTE_COMMIT, o coordenador envia para todos os participantes um GLOBAL_COMMIT sen√£o envia um GLOBAL_ABORT;
    		- Cada participante confirma ou aborta a sua transa√ß√£o local, conforme receba GLOBAL_COMMIT ou GLOBAL_ABORT, respectivamente;


## Transa√ß√µes em Bancos de Dados Relacionais e NO-SQL

- Introdu√ß√£o a transa√ß√µes
    - SGBD
        - Sistema de processamento de opera√ß√µes de acesso ao BD;
    - SGBDs s√£o em geral multi-usu√°rios
        - Processam simultaneamente opera√ß√µes disparadas por v√°rios usu√°rios;
            - Deseja-se alta disponibilidade e tempo de resposta
            pequeno;
        - Execu√ß√£o intercalada de conjuntos de opera√ß√µes;
    - Opera√ß√µes s√£o chamadas transa√ß√µes;

- Conceito de transa√ß√£o
    - Unidade l√≥gica de processamento em um SGBD;
    - Composta de uma ou mais opera√ß√µes;
        - Seus limites podem ser determinados em SQL;
    - De forma abstrata e simplificada, uma transa√ß√£o pode ser encarada como um conjunto de opera√ß√µes de leitura e escrita de dados;

- Estados de uma transa√ß√£o
    - Uma transa√ß√£o √© sempre monitorada pelo SGBD quanto ao seu estado;
        - Que opera√ß√µes j√° fez? Concluiu suas opera√ß√µes? Deve abortar?
    - Estados de uma transa√ß√£o;
        - Ativa, Em processo de efetiva√ß√£o, Efetivada, Em falha, Em Efetiva√ß√£o(Conclu√≠da);
        - Respeita um Grafo de Transi√ß√£o de Estados;

- Propriedades de uma transa√ß√£o nos SGBDs Relacionais
    - Requisitos que sempre devem ser atendidos por uma transa√ß√£o;
    - Chamadas de propriedades ACID: Atomicidade, Consist√™ncia, Isolamento e Durabilidade (Persist√™ncia);
	
- Sobre ACID:
	- Atomicidade
    		- Princ√≠pio do ‚ÄúTudo ou Nada‚Äù;
        			- Ou todas as opera√ß√µes da transa√ß√£o s√£o efetivadas (commit) com sucesso no BD ou nenhuma delas se efetiva (rollback) (preservar a integridade do BD);
    		- Responsabilidade do subsistema de recupera√ß√£o contra falhas (subsistema de recovery) do SGBD;
        			- Desfazer (rollback) as a√ß√µes de transa√ß√µes parcialmente executadas;
    		- Deve ser garantida, pois uma transa√ß√£o pode manter o BD em um estado inconsistente durante a sua execu√ß√£o;
	- Consist√™ncia
   		 - Uma transa√ß√£o sempre conduz o BD de um estado consistente para outro estado tamb√©m consistente;
    		- Responsabilidade do conjunto
        			- DBA: definir todas as RIs para garantir estados e transi√ß√µes de estado v√°lidos para os dados;
        		- Subsistema de recovery;
            			- Desfazer as a√ß√µes da transa√ß√£o que violou a integridade;		

	- Isolamento
   		 - No contexto de um conjunto de transa√ß√µes concorrentes, a execu√ß√£o de uma transa√ß√£o Tx deve funcionar como se Tx executasse de forma isolada;
        			- Tx n√£o deve sofrer interfer√™ncias de outras transa√ß√µes executando concorrentemente;
    		- Responsabilidade do subsistema de controle de concorr√™ncia (scheduler) do SGBD;
       			 - Garantir escalonamentos sem interfer√™ncias;

	- Durabilidade
    		- Deve-se garantir que as modifica√ß√µes realizadas por uma transa√ß√£o que concluiu com sucesso persistam no BD;
        			- Nenhuma falha posterior ocorrida no BD deve perder essas modifica√ß√µes;
    		- Responsabilidade do subsistema de recovery;
       			- Refazer transa√ß√µes que executaram com sucesso em caso de falha no BD;

- Serializa√ß√£o
    - O sistema gerenciador de banco de dados deve controlar a execu√ß√£o concorrente de transa√ß√µes para assegurar que o estado do banco de dados permane√ßa consistente;
    - A consist√™ncia do banco de dados, sob execu√ß√£o concorrente, pode ser assegurada garantindo-se que qualquer escala executada concorrentemente tenha o mesmo efeito de outra que tivesse sido executada sem qualquer concorr√™ncia;
    - Isto √©, uma escala de execu√ß√£o deve, de alguma forma, ser equivalente a uma escala seq√ºencial (transa√ß√µes sem intercala√ß√£o, executadas de forma serial);
    - Formas de equival√™ncia entre escalas de execu√ß√£o podem ser verificadas sob duas vis√µes:
        - Por conflito
	* Diz-se que duas transa√ß√µes entram em conflito quando transa√ß√µes diferentes agem em um mesmo item de dados, e pelo menos uma dessas opera√ß√µes √© de escrita (write);
        - Por vis√£o;


- Propriedades Transacionais nos BDs NO-SQL:
    - Bancos de dados relacionais tem problemas
        	- Escalabilidade vertical (adicionar recursos de hardware a uma mesma m√°quina ( + mem√≥ria, + armazenamento, + processadores, + velocidade de processamento) ‚Üí limite f√≠sico computacional e alto custo);
        	- Escalabilidade horizontal (particionar os dados em v√°rias m√°quinas, torna a manuten√ß√£o das tabelas bem dif√≠cil e complicado; depende da fragmenta√ß√£o se √© horizontal (linhas) ou vertical (colunas));
        	- Alto volume de dados com baixa velocidade de resposta
	- Os dados mudam constantemente
               	- Protocolos de bloqueio de efetiva√ß√£o em duas fases distribu√≠do (para preservar as propriedades ACID, em especial a consist√™ncia, aumentam consideravelmente o tempo de resposta do sistema ‚Üí lat√™ncia muita alta implica em baixa disponibilidade);

    - Bancos de dados NO-SQL precisam de alta disponibilidade e redund√¢ncia (mesmo dado em muitos n√≥s) ‚Üí n√£o √© poss√≠vel usar propriedades ACID;


- Propriedades BASE:
    - Basically Available - Basicamente Dispon√≠vel: disponibilidade √© prioridade, o sistema deve estar em funcionamento na maior parte do tempo;
    - Soft-State - Estado Leve: n√£o precisa ser consistente o tempo todo;
    - Eventually Consistent - Eventualmente consistente: consistente em algum momento n√£o determinado, a consist√™ncia nem sempre √© mantida para todos os n√≥s, n√≥s podem n√£o ter a mesma vers√£o dos dados;
    - Diferen√ßas ACID / BASE:

	ACID                                                   | BASE
-------------------------------------------------------+---------------------------------------------------------
Consist√™ncia forte                                     | Fraca consist√™ncia
Isolamento                                             | Disponibilidade em primeiro lugar
Concentra-se em "commit"                               | Melhor esfor√ßo em disponibilidade para parti√ß√µes
Transa√ß√µes aninhadas                                   | Respostas aproximadas
Conservador (pessimista, bloqueia todos os registros   | Agressivo (otimista, detectam os conflitos e depois faz
para evitar conflitos)                                 | o tratamento)
Evolu√ß√£o dif√≠cil (por exemplo, esquema)                | Evolu√ß√£o mais f√°cil

- Teorema CAP:
    - O Teorema CAP explica por que sistemas modernos (como bancos distribu√≠dos globais) n√£o podem ser 100% consistentes, 100% dispon√≠veis e 100% tolerantes a falhas ao mesmo tempo
    - Sempre √© preciso escolher duas dessas propriedades e abrir m√£o de uma:

	1. Consist√™ncia (Consistency)
		- Em bancos de dados relacionais tradicionais (ACID), a consist√™ncia garante que ap√≥s uma transa√ß√£o confirmada (commit), todos os clientes enxergar√£o o mesmo valor atualizado, independentemente do n√≥ de leitura (exemplo: Se uma transa√ß√£o de transfer√™ncia banc√°ria confirma que R$100 sa√≠ram da conta A e foram para a conta B, qualquer cliente que consulte A ou B ver√° os valores atualizados).
		- Em sistemas distribu√≠dos AP (Disponibilidade + Parti√ß√£o), essa consist√™ncia pode ser eventual: a leitura pode retornar dados antigos at√© que todos os n√≥s sejam sincronizados.

	2. Disponibilidade (Availability)
		- Um sistema dispon√≠vel garante que mesmo que alguns n√≥s falhem, ainda √© poss√≠vel ler e escrever dados em outros n√≥s que estejam ativos.
		- Exemplo em transa√ß√µes: Um banco digital que n√£o pode parar nunca precisa garantir que o cliente consiga registrar uma compra com cart√£o mesmo que parte do sistema esteja fora do ar. A opera√ß√£o pode ser aceita localmente e depois sincronizada quando o n√≥ voltar.
		- O custo: pode-se ler dados desatualizados, mas o sistema nunca "cai".

	3. Toler√¢ncia a Particionamento (Partition Tolerance)
		- Em bancos de dados distribu√≠dos, parti√ß√µes podem ocorrer quando a rede falha e n√≥s ficam isolados em grupos.
		- O sistema precisa continuar funcionando mesmo sem comunica√ß√£o total entre os n√≥s.
		- Exemplo em transa√ß√µes: Em um marketplace global, se o datacenter da Europa perde contato com o dos EUA, cada regi√£o deve continuar processando pedidos localmente. Depois, quando a rede voltar, os dados s√£o sincronizados (pode gerar conflitos que precisar√£o ser resolvidos).

- Sistemas CAP aplicados em Bancos de Dados
	üìå CA (Consist√™ncia + Disponibilidade)
	N√£o toleram parti√ß√µes ‚Üí funcionam apenas em sistemas centralizados (um √∫nico n√≥ ou cluster muito coeso).
	Exemplo: Bancos de dados relacionais tradicionais (MySQL, PostgreSQL em modo standalone).
	Em transa√ß√µes: garantem ACID, mas se o servidor cair, o sistema todo fica indispon√≠vel.

	üìå CP (Consist√™ncia + Particionamento)
	Mant√™m consist√™ncia mesmo em falha de rede, mas podem sacrificar a disponibilidade (o sistema pode ficar indispon√≠vel at√© sincronizar).
	Exemplo: HBase, MongoDB com Write Concern alto, sistemas de consenso como Zookeeper.
	Em transa√ß√µes:
	Uma transfer√™ncia banc√°ria cr√≠tica pode ser bloqueada at√© que todos os n√≥s confirmem, garantindo que nunca haja saldo incorreto.

	üìå AP (Disponibilidade + Particionamento)
	Nunca ficam indispon√≠veis, mas aceitam abrir m√£o da consist√™ncia forte, adotando consist√™ncia eventual.
	Exemplo: Cassandra, DynamoDB, CouchDB.
	Em transa√ß√µes:
	Redes sociais: voc√™ publica uma foto e um amigo pode demorar alguns segundos para v√™-la em outro servidor.
	O importante √© que o sistema nunca para.

	üîπ Modelos de Distribui√ß√£o relacionados a transa√ß√µes

	Particionamento (Sharding)
	Divide os dados entre servidores diferentes ‚Üí transa√ß√µes podem precisar consultar m√∫ltiplos shards.

	Replica√ß√£o
	Copia os dados ‚Üí garante maior disponibilidade de leitura, mas pode gerar conflitos de escrita.

	Particionamento + Replica√ß√£o
	Combina os dois ‚Üí muito usado em bancos NoSQL modernos.

	üîπ Qu√≥runs em transa√ß√µes distribu√≠das

	Qu√≥rum de escrita: uma transa√ß√£o s√≥ √© considerada confirmada se atingir N confirma√ß√µes de n√≥s.
		W = qu√≥rum de escrita
			ÔÅ¨ n√∫mero de n√≥s que confirmam uma escrita
		N = fator de replica√ß√£o dos dados
			ÔÅ¨ n√∫mero de r√©plicas
		Para garantir escritas com consist√™ncia forte, a seguinte f√≥rmula precisa ser respeitada:
			W > N / 2
		O n√∫mero de n√≥s que confirmam uma escrita precisa ser maior que a metade do n√∫mero de r√©plicas do item a ser escrito, ou seja, a maioria

	Qu√≥rum de leitura: garante que uma leitura s√≥ √© v√°lida se consultar n√≥s suficientes para evitar dados antigos.
	Isso d√° mais previsibilidade em consist√™ncia eventual.
		Quantos n√≥s √© preciso contatar para se ter a garantia de que o valor mais recente para um item de dado foi lido?
			ÔÅ¨ A resposta depende do qu√≥rum de escrita W
		ÔÅ¨ R = qu√≥rum de leitura
			ÔÅ¨ n√∫mero de n√≥s contatados para a leitura
		ÔÅ¨ Para garantir leituras altamente consistentes, a seguinte f√≥rmula precisa ser respeitada:
			R + W > N
		ÔÅ¨ A f√≥rmula garante que, entre os R n√≥s de r√©plicas contatados, haver√° pelos menos 1 que tem a vers√£o mais nova do item de dado
		
- Tabela Comparativa CAP:

                          TEORIA CAP
                               |
        -------------------------------------------------
        |                        |                      |
   CONSIST√äNCIA (C)        DISPONIBILIDADE (A)    PARTICIONAMENTO (P)
        |                        |                      |
  Leitura sempre do        Sempre responde,       Sistema continua
  dado mais recente        mesmo se n√≥s falharem  funcionando mesmo
  (consist√™ncia forte).    (nunca fica offline).  em falhas de rede.
        |                        |                      |
        |                        |                      |
        -------------------------------------------------
                               |
                     N√£o √© poss√≠vel garantir
                  C + A + P ao mesmo tempo
                               |
     -------------------------------------------------------
     |                        |                            |
    CA                       CP                           AP
(Consist√™ncia +            (Consist√™ncia +            (Disponibilidade +
 Disponibilidade)           Particionamento)           Particionamento)
     |                        |                            |
  - Bancos ACID            - Consist√™ncia forte,       - Sempre dispon√≠vel
  - MySQL, PostgreSQL        mas menor                - Consist√™ncia eventual
  - Funciona bem em          disponibilidade          - Cassandra, DynamoDB
    ambiente centralizado   - Ex: HBase, Zookeeper     - Rede sociais, apps
  - Se o servidor cai,      - √ötil p/ dados cr√≠ticos     globais
    sistema todo cai          (ex: leil√µes)              (mensagens, posts)


---------------------------------------------------//-----------------------------------------------//------------------------------------------------//------------------------------------------//


4 - REPLICA√á√ÉO MASTER-SLAVE

    
    - A escrita √© realizada somente em um servidor chamado Master;
    - Os demais servidores do Cluster s√≥ permitem leitura, Slave;
    - Confirma√ß√£o de escrita no Master
        - Se houver alguma estrat√©gia de confirma√ß√£o de escrita antes de propagar, a leitura no slave pode ser desatualizada (perdemos a consist√™ncia por pouco tempo);
    - Falhas
        - Uma falha no master antes da propaga√ß√£o significa perda de dados;
        - Falha na comunica√ß√£o n√£o compromete a leitura e escrita no Master, mas a leiturs no Slave ser√° desatualizada;
    - Aumentar a consist√™ncia
        - No Master, escrita √© mais lenta ‚Üí lat√™ncia da comunica√ß√£o;
        - No Slave, dado salvo somente ap√≥s confirma√ß√£o de escrita no Slave ‚Üí consist√™ncia;
    - Limita√ß√µes
        - Limita√ß√£o: todas as escritas serem realizadas no master;
        1. Queda na performance com muitas requisi√ß√µes;
        2. Uma falha no servidor, o servi√ßo ser√° comprometido;

	*Masterless: - Alternativa: muitos bancos NoSQL s√£o baseados na ideia de que qualquer servidor pode receber requisi√ß√µes de leitura e escrita;